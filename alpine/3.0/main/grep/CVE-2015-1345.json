{
  "IssueID": 3865,
  "VulnerabilityID": "CVE-2015-1345",
  "Release": "3.0",
  "Package": "grep",
  "Repository": "main",
  "FixedVersion": "2.19-r1",
  "Subject": "[v3.0] grep: heap buffer overrun (CVE-2015-1345)",
  "Description": "\r\n\r\nInvoking grep with a carefully crafted combination of input and regexp can cause a segfault and/or reading from uninitialized memory.\r\n\r\nHere's how it evolved: http://bugs.gnu.org/19563\r\nHere's the upstream fix: http://git.sv.gnu.org/cgit/grep.git/commit/?id=83a95bd8c8561875b948cadd417c653dbe7ef2e2\r\n\r\nThe comment to the fix mentions:\r\ngrep's read buffer is often filled to its full size, except when reading the final buffer of a file. In that case, the number of bytes read may be far less than the size of the buffer. However, for certain unusual pattern/text combinations, grep -F would mistakenly examine bytes in that uninitialized region of memory when searching for a match. With carefully chosen inputs, one can cause grep -F to\r\nread beyond the end of that buffer altogether. This problem arose via commit v2.18-90-g73893ff with the introduction of a more efficient heuristic using what is now the memchr_kwset function. The use of\r\nthat function in bmexec_trans could leave TP much larger than EP, and the subsequent call to bm_delta2_search would mistakenly access eyond end of the main input read buffer.\r\n\r\nSo it seems that versions before v2.18 are not vulnerable. This was kept in mind desiding of what Alpine Linux branches are vulnerable.\r\n\r\nReferences:\r\nhttp://seclists.org/oss-sec/2015/q1/221\r\nhttp://debbugs.gnu.org/cgi/bugreport.cgi?bug=19563\r\nCONFIRM: http://git.savannah.gnu.org/cgit/grep.git/commit/?id=83a95bd8c8561875b948cadd417c653dbe7ef2e2\r\n"
}