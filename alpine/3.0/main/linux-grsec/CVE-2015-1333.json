{
  "IssueID": 4599,
  "VulnerabilityID": "CVE-2015-1333",
  "Release": "3.0",
  "Package": "linux-grsec",
  "Repository": "main",
  "FixedVersion": "3.14.22-r2",
  "Subject": "[v3.0] kernel: kernel keyring that can be used to cause a local denial of service (CVE-2015-1333)",
  "Description": "While improving the system call coverage in stress-ng[1], a bug was discovered in the Linux kernel keyring that can be used to cause a local denial of service due to memory exhaustion when the same key is repeatedly added to the kernel keyring via the add_key() syscall.\r\n\r\n__key_link_end is not freeing the associated array edit structure and this leads to a 512 byte memory leak each time an identical existing key is added with add_key().\r\n    \r\nThe reason the add_key() system call returns okay is that key_create_or_update() calls __key_link_begin() before checking to see whether it can update a key directly rather than adding/replacing - which it turns out it can.  Thus __key_link() is not called through    __key_instantiate_and_link() and __key_link_end() must cancel the edit.\r\n\r\nThe following commit introduced the issue:\r\n\r\n  commit 034faeb9ef390d58239e1dce748143f6b35a0d9b\r\n  Date:   Wed Oct 30 11:15:24 2013 +0000\r\n  \r\n      KEYS: Fix keyring quota misaccounting on key replacement and unlink\r\n\r\nWhich means that v3.13 and newer kernels are affected:\r\n\r\n  $ git describe --contains 034faeb9ef390d58239e1dce748143f6b35a0d9b\r\n  v3.13-rc1~18^2~6^2~2\r\n\r\n\r\nupstream commit:\r\n\u003e ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0 \r\n\r\nlinux-3.14:\r\n\u003e c9cd9b18dac801040ada16562dc579d5ac366d75\r\n\r\nlinux-3.18:\r\n\u003e 66db51c9f7b2fe7ebdfa753b2aa9abbb9feddc87\r\n\r\n\r\nReference:\r\n\u003e http://seclists.org/oss-sec/2015/q3/227\r\n\u003e http://permalink.gmane.org/gmane.linux.kernel/2009941\r\n\u003e https://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.14.49\r\n\u003e https://www.kernel.org/pub/linux/kernel/v3.0/ChangeLog-3.18.20"
}